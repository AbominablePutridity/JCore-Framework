![Описание изображения](./JCoreIcon.png)

JCore - Документация на фреймворк:

JCore - легковестный фреймворк для создания простых веб-приложений и API-сервисов, построенный на сокетной коммуникации
и состоит из 4х главных компонентов:

1) DI - внедрение зависимостей 
2) взаимодействии с базой данных (под копотом jdbc) - создание обьектов на базе описанных сущностей (src/main/java/vendor/EntityOrm).
3) обработка данных при помощи контроллеров, работа сервера (src/main/java/vendor/ControllerComponent).
4) защита роутов - Security модуль.

Рассмотрим два этих компонента поподробнее:

Глава1: Начиная

#ВНЕДРЕНИЕ ЗАВИСИМОСТЕЙ (DI)
Dependensy Injection (DI) - внедрение компонентов обьектов, считающихся системной частью фреймворка производится по пути:
vendor/DI

Имеются 2 основных компонента:
I) ContainerDI - хранит в себе, непосредственно, сам DI контейнер в формате HashMap<Key, Value>:
	- Где Key - тип класса обьекта, которого нужно достать
	- А Value - сам обьект, который будем внедрять.

	Также имеются 2 метода:
	1) register - для регистрации обьекта как зависимость (по сути, метод-сеттер для задачи значения в контейнер DI)
	2) getBean - для взятия обьекта по типу класса.

	все методы являются статичными, потому как, для управления контейнером зависимостей создавать его обьект не требуется.

II) ConfigDI - отвечает за внедрение в контейнер по умолчанию всех необходимых системных компонентов бинов (обьектов).
	Имеет в себе статический метод setBeans(), который как раз заполняет контейнер 3мя дэфолтными компонентами (обьектами):
	1) обьект Controller - для маршрутизации запросов клиента в контроллеры.
	2) обьект Server([бин компонента Controller для маршрутизации], [порт, на котором будет работать]) - для работы сервера, роутинга по контроллерам и обработки клиентских запросов
	3) обьект Connection - для подключения к бд, является компонентом JDBC. Отвечает за подключение к БД (по данным из конфига для бд - ConfigJDBC)
	4) обьект Statement - выполняет запросы бд на основе обьекта подключения (из пункта 2). Его нужно будет часто передавать в классы-контроллеры и классы-сущности, в качестве параметра конструктора для выполнения запросов под капотом

- этот метод вызывается при старте приложения, в методе main() - самый первый, для инициализации контейнера (установки в него обьектов)

На основе этого вы можете легко писать свои модули, внедрять их в контейнер через конфиг, и легко брать из контейнера по типу класса в качестве ключа, вызывая метод getBean класса ContainerDI


Глава2: Взаимодействие с базой данных, работа с сущностями

#КОНФИГУРАЦИЯ
Все основные компоненты фреймворка находятся по пути src/main/java/vendor, и являются самописными на языке java.

Начнем с рассмотрения компонента базы данных (src/main/java/vendor/EntityOrm), за это отвечает главный класс Entity в папке фреймворка
src/main/java/vendor/EntityOrm/Entity.

Но перед тем, как использовать этот класс нужно:
1) в конфигурационном файле управлением JDBC (src/main/java/vendor/EntityOrm/ConfigJDBC)
 - настроить строку подключения к БД на свою (переменная urlConnection)
 - настроить пользователя и пароль к бд на свои (переменные userName и password соответственно)

По умолчанию, в проекте, в файле с зависимостями .pom стоит зависимость от postgreSql (можно заменить на любой другой драйвер реляционной бд)

После конфигурирования базы данных приступим к созданию подключения, в главном запускающем классе (пока что для демонстрации) пропишим необходимые для подключения строки:

```java
public class JCore {

    public static void main(String[] args) throws SQLException, IllegalArgumentException, IllegalAccessException, IOException {
	...
	
        //инициализация бинов в контейнере
        ConfigDI.setBeans(); 
	/*
	 как раз вызов метода инициализации бинов создает обьекты, необходимые для выполнения запросов к бд, и не полько;
	*/ 
	...
```

#СУЩНОСТИ
После настройки базы данных приступим к созданию сущности:

В данном фреймворке сущности строятся полностью на базе аркитектуры любого класса, допустим у нас есть две сущности:
Пользователь (Person) и Автомобиль (Car). Представим, что в нашей системе у каждого Автомобиля автомобиля обязательно будет свой Пользователь
=> связь между сущностями 1:М (Ключ пользователя будет от автомобиля).

Посмотрим на реализацию такой схемы в JCore:

Пользователь:

```java
package com.mycompany.jcore.entities;
import java.sql.Statement;
import vendor.EntityOrm.Entity;

public class Person extends Entity {
    public String name;
    public String surname;

    public Person(Statement statement) {
        super(statement); // передаем обьект для создания запросов родителю
    }    
}
```

- в этом классе мы обозначили, что в нашей сущности Пользователь (а позже и в нашей таблице) будет 2 аттрибута:
Имя и Фамилия - для простого примера нам будет достаточно.
Также данный класс не имеет поля с первичным идентификатором, но главная его особенность в том, что он наследуется од абстрактного класса Entity,
что позваляет классу Person иметь все свойства компонента сущности, такие как:
 - id - первичный ключ
 - refs - ссылки на сушности (внешние ключи в формате ArrayList<RelationField> - об этом позже)
 - statement - стандартный обьект класса jdbc - Statement для выполнения SQL комманд (который как раз и принимает в себя конструктор класса Entity, для реализации в потомке)
а также методы:
 - initializeChild - создание обьекта с метаданными потомка на основании которых будет строиться управление последующими классами.
 - createTable - создание таблиц в БД на базе метаданных сущности
 - insertData - вставка данных в сущность этого типа.
 - getData - выборка данных из сущности этого типа.
 - updateData - обновление данных сущности этого типа.
 - deleteData - удаление данных из сущности этого типа.
 - printResultSetSimple - для вывода в консоль результатов запроса.

Далее - описание сущности Машины:

```java
package com.mycompany.jcore.entities;
import java.sql.Statement;
import vendor.EntityOrm.Entity;
import vendor.EntityOrm.RelationField;

public class Car extends Entity {
    public String mark;
    public String color;
    public Long personId; //ключи - всегда называем в loverCamelCase, имя связующего класса + постфикс "Id" в конце названия
    
    //связь
    public Car(Statement statement) {
        super(statement); // передаем обьект для создания запросов родителю
        
        refs.add(new RelationField(Person.class, personId)); //связь с персоной машины
    }
}
```

 - здесь уже добавляется поле personId, которое является внешним ключом на сущность Пользователя, тут интересно правило наименования ключа:
[имяКлассаНаКотороеСсылветсяПоле] + Id - в нашем случае имя класса для связки Person, значит по правилу - получаем внешний ключ personId, и тд...

Также, в конструкторе, помимо передачи обьекта для выполнения комманд statement в родительский класс Entity, также в лист со внешними ключами refs создаем новый элемент-ссылку на класс
refs.add(new RelationField(Person.class, personId)); //связь с персоной машины

Поздравляю! теперь мы подготовили нашу структуру данных для ее использования.

#ИСПОЛЬЗОВАНИЕ СУЩНОСТЕЙ

Для простого примера, создадим такой код в запускающем методе main():

```java
public static void main(String[] args) throws SQLException, IllegalArgumentException, IllegalAccessException, IOException {
        //инициализация бинов в контейнере
        ConfigDI.setBeans();
        
        //запуск сервера
        Server server = ContainerDI.getBean(Server.class); //берем бин сервера из DI-контейнера
        
        // регестрируем все наши контроллеры на сервере (для роутинга)
        server.controllerPull.declaredControllers.add(new PersonController(ContainerDI.getBean(Statement.class)));
        
        server.startServer(); //запускаем сервер
        
        
        //пример работы с БД
        
        // Создаем сущности
        Person person1 = new Person(ContainerDI.getBean(Statement.class));
        person1.id = 1;
        person1.name = "Иван";
        person1.surname = "Иванов";
        person1.role = "USER";
        
        System.out.println(person1.initializeChild().toString());

        // На основании описанных выше обьектов, создаем таблицы
        System.out.println(person1.createTable(person1.initializeChild()));
        
        // Передаем данные обьекта таблице в БД
        System.out.println(person1.insertData(person1.initializeChild()));
        
        // тоже самое с машиной
        Car car1 = new Car(ContainerDI.getBean(Statement.class));
        car1.id = 1;
        car1.mark = "Таета";
        car1.color = "черный";
        car1.personId = Long.valueOf("1");
        
        System.out.println(car1.initializeChild().toString());
        
        // Передаем данные обьекта таблице в БД
        System.out.println(car1.insertData(car1.initializeChild()));
    }
```

- здесь, на основе наших сущностей мы создаем обьекты и из нашего DI контейнера передаем каждой сущности обьект Statement в их конструктор, для выполнения запросов в БД под копотом.

ПОЗДРАВЛЯЮ!!! вы создали схему таблиц и заполнили ее данными из обьектов.


Глава3: Обработка данных при помощи контроллеров, работа сервера.

#КОНТРОЛЛЕРЫ, МАРШРУТИЗАЦИЯ И РОУТИНГ

Для примера, создадим класс-контроллер, который будет запускаться каждый раз, при обращении к нему запроса от клиента:

```java
package com.mycompany.jcore.controller;

import java.sql.Statement;
import vendor.Security.Security;

/**
 * Пример контроллера с выводом переданных параметров клиенту.
 * @author User
 */
public class PersonController {
    
    /* telnet 127.0.0.1 8082
    запрос (через коммандную строку): PersonController/createPersonAction<endl>helloWorld!<endl>JCore!<endl>
    */
    public String createPersonAction(String[] params)
    {
        String result = "";
        
        for(String param : params)
        {
            result += "param is -> " + param + "\r\n";
            System.out.println("param is -> " + param);
        }
            
        return result;
    }
}
```

- Здесь очень важно правильно назвать класс-контроллер и его методы (экшены), ведь из них складывается строка к доступу (роуту) для выполнения метода.
String[] params - переданные параметры от клиента в строке запроса от него (request).

Отлично, мы написали класс-контроллер с примером вывода в консоль всех переданных параметров клиента и возвращением параметров клиента с сервера обратно клиенту как ответ сервера (response).

Далее механизм роутинга мы осветим чуть подробнее:


#СЕРВЕР

Сервер представляет из себя класс Server, который отвечает за связку клиента с программой путем соединения через ServerSocket.
Клиент подключается к серверу, отдает запрос -> сервер обрабатывает запрос, формирует ответ -> возвращает ответ клиенту и закрывает соединение.
И так обрабатывается каждый запрос.

Запрос клиента состоит из роута, в формате "классКонтроллера/методДляВыполнения<endl>данные параметра 1<endl>данные параметра 2<endl>..."
- данные параметров в запросе клиента может быть сколько угодно.

Ответ от сервера принимается в формате строки.

(Все современные браузеры получают данные в формате строки, которая в свою очередь парсится и преобразоввывается сериализатором обратно в обьект,
а ответ - обработанные данные, которые в свою очередь также представляются в виде строки, которую должна быт распаршена на клиентской части для извлечения и отрисовки данных,
поэтому был выбран такой архитектурный прием в виде строки-запроса, данные которой парсятся в массив параметров в данном фреймворке и строки-ответа,
которая, в свою очередь, должна быть распаршена на стороне клиента).

Очень важный момент - сервер имеет в себе обьект Controller, который хранит в себе все роуты для отправки в них запросов на клиенте (об этом подробнее чуть позже).

Для запуска и корректной работы сервера для работоспособности нашего написанного выше контроллера, в main запускающем методе требуется прописать следующее:

```java
public static void main(String[] args) {
	//инициализация бинов в контейнере
        ConfigDI.setBeans(); //(1)
        
        //запуск сервера
        Server server = ContainerDI.getBean(Server.class); //берем бин сервера из DI-контейнера (2)
        
        // регестрируем все наши контроллеры на сервере (для роутинга) (3)
        server.controllerPull.declaredControllers.add(new PersonController());
        
        server.startServer(); //запускаем сервер (4)
}
```

- здесь мы инициализируем DI-контейнер т.к. наш обьект сервера находится в нем (1),
на второй строке - берем обьект сервера из контейнера для дальнейшего взаимодействия с ним (2),
у обьекта сервера есть поле controllerPull типа класса Controller, в реализации которого есть коллекция declaredControllers<>,
которая хранит в себе все обьекты контроллеров, которые будут работать на сервере. В нашем случае, в коллекцию контроллеров для сервера мы положим обьект контроллера нашего новосозданного класса PersonController - таким же образом, в коллекцию передаем все наши контроллеры (3).
Далее даем команду серверу на запуск, вызвав у него на обьекте метод startServer (4).

Готово, можно запускать!

Как работает роутинг?

При подключении по Сокетному соединению клиента (telnet [IP-адресс (локально - 127.0.0.1)] [порт (по умолчанию - 8082)])
можно будет отправить запрос в следующем формате: "PersonController/createPersonAction<endl>helloWorld!<endl>JCore!<endl>",

Где PersonController/createPersonAction - имя роута, которое парсится по символу "/", извлекается имя класса и ищется в коллекции declaredControllers<>.
Если обьект класса присутствует в коллекции, у него вызывается метод в роуте, идущий после символа "/".

после определения роута, строка запроса парсится по делиметру строки "<endl>", и все параметры, идущие после роута, передаются в сигнатуру запускающего метода, в параметр String[] params - в нашем случае: createPersonAction(String[] params)


Глава4: Защита роутов, Security модуль.

Защита роута осуществляется путем проверки логина и пароля пользователя (аутентификации пользователя в системе).
Если введенный логин пользователем существует и совпадает вместе с введенным паролем в базе данных, то у пользователя обязательно берется роль из базы данных и сверяется с ролью для доступа к ресурсу (роуту).
Если роли совпадают - пользователь может спокойно осуществить свой запрос по роуту и получить обработанный ответ от сервера.

Посмотрим, как это можно использовать на практике - для начала в сущности пользователя создадим необходимые поля для защиты роута:

```java
package com.mycompany.jcore.entities;
import java.sql.Statement;
import vendor.EntityOrm.Entity;

/**
 * 
 * @author maxim
 */
public class Person extends Entity {
    public String name;
    public String surname;
    
    public String login; //добавляем поле с логином для входа пользователя
    public String password; //добавляем поле с паролем для входа пользователя
    public String role; //добавляем поле с ролью пользователя

    public Person(Statement statement) {
        super(statement); // передаем обьект для создания запросов родителю
    }    
}
```

- в этом примере мы добавляем необходимые поля для дальнейшей работой над защитой нашего роута.

Далее - перейдем в класс-контроллер для защиты нашего роута:

```java
package com.mycompany.jcore.controller;

import java.sql.Statement;
import vendor.Security.Security;

/**
 * Пример контроллера с выводом переданных параметров клиенту.
 * @author User
 */
public class PersonController extends Security { //наследуемся от компонента Security для защиты роута.
    
    public PersonController(Statement statement) { //в конструкторе передаем обьект JDBC для выполнения запросов (передается в родительский класс Security)
        super(statement);
    }
    
    /* telnet 127.0.0.1 8082
    запрос (через коммандную строку): PersonController/createPersonAction<endl>helloWorld!<endl>JCore!<endl>ivanov<security>pass<endl>
    */
    public String createPersonAction(String[] params)
    {
        String result = ""; //строка с ответом от сервера, которую будем возвращать клиенту.
        
	//([из какой таблицы], [имя поля логина в таблице], [имя поля пароля в таблице], [имя поля роли в таблице], [Имя роли, которой можно выполнять запрос], [параметры запроса])
        if(super.checkRole("Person", "login", "password", "role", "USER", params)) { //проверка пользователя (Security-модуль)   
            for(String param : params)
            {
		// если логин и пароль из запроса совпадут со значениями из БД, и роль найденого пользователя будет равна (в нашем случае "USER")
		//то запрос выполнится
                result += "param is -> " + param + "\r\n";
                System.out.println("param is -> " + param);
            }
            
            return result;
        } else {
	    //иначе выведит ошибку доступа.
            return super.returnException();
        }
    }
}
```

- далее - очень важный момент:

1) для Security нужен обьект Statement, поэтому, для его передачи - создаем конструктор.
2) основное условие для доступа по роуту находится в контроллере, и в теле этого условия (в идеале), должен вызываться метод из сервиса, который отвечает за обработку данных и возвращение результата в формате ответа.
3) сигнатура метода checkRole родительского класса состоит из:
([из какой таблицы сравниваем и берем данные для проверки аутентификации], [имя поля логина в таблице], [имя поля пароля в таблице], [имя поля роли в таблице], [Имя роли, которой можно выполнять запрос], [параметры запроса - массив параметров контроллера])
- возвращает Булевое значение и отвечает за то, прошел ли пользователь аутентификацию, либо же нет.
4) Запрос клиента с запросом после подключения модуля Security ОБЯЗАТЕЛЬНО ДОЛЖЕН ИМЕТЬ БЛОК <endl>[логин пользователя для сверки с БД]<security>[пароль пользователя для сверки с БД]<endl>

Например, если у пользователя в БД будет логин - ivanov, а пароль - pass, то целевой запрос к нашему роуту будет выглядеть следующим образом:
PersonController/createPersonAction<endl>helloWorld!<endl>JCore!<endl>ivanov<security>pass<endl>

Далее - в запускаемом методе, для примера - вручную создадим сущности и заполним их данными:

```java
package com.mycompany.jcore;

import com.mycompany.jcore.controller.PersonController;
import com.mycompany.jcore.entities.Car;
import com.mycompany.jcore.entities.Person;
import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import vendor.ControllerComponent.Connection.Server;
import vendor.ControllerComponent.Controller;
import vendor.DI.ConfigDI;
import vendor.DI.ContainerDI;
import vendor.EntityOrm.ConfigJDBC;
import vendor.JCoreMeta;

/**
 *
 * @author maxim
 */
public class JCore {

    public static void main(String[] args) throws SQLException, IllegalArgumentException, IllegalAccessException, IOException {
        //инициализация бинов в контейнере
        ConfigDI.setBeans();
        
        //запуск сервера
        Server server = ContainerDI.getBean(Server.class); //берем бин сервера из DI-контейнера
        
        // регестрируем все наши контроллеры на сервере (для роутинга)
        server.controllerPull.declaredControllers.add(new PersonController(ContainerDI.getBean(Statement.class)));
        
        server.startServer(); //запускаем сервер
        
        
        //пример работы с БД
        
        // Создаем сущности
        Person person1 = new Person(ContainerDI.getBean(Statement.class));
        person1.id = 1;
        person1.name = "Иван";
        person1.surname = "Иванов";
        person1.login = "ivanov";
        person1.password = "pass";
        person1.role = "USER";
        
        System.out.println(person1.initializeChild().toString());

        // На основании описанных выше обьектов, создаем таблицы
        System.out.println(person1.createTable(person1.initializeChild()));
        
        // Передаем данные обьекта таблице в БД
        System.out.println(person1.insertData(person1.initializeChild()));
        
        // тоже самое с машиной
        Car car1 = new Car(ContainerDI.getBean(Statement.class));
        car1.id = 1;
        car1.mark = "Таета";
        car1.color = "черный";
        car1.personId = Long.valueOf("1");
        
        System.out.println(car1.initializeChild().toString());
        
        // Передаем данные обьекта таблице в БД
        System.out.println(car1.insertData(car1.initializeChild()));
    }
}
```

- запустим программу и совершим запрос - PersonController/createPersonAction<endl>helloWorld!<endl>JCore!<endl>ivanov<security>pass<endl>

Готово! вы увидите, что запрос успешно отработает. Чтобы посмотреть, как он отреагирует на неправильный логин и пароль, можете изменить запрос в блоке
<endl>ivanov<security>pass<endl> - подставив некорректный логин и пароль, например <endl>ivanov123<security>pass123<endl>