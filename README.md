![Описание изображения](./JCoreIcon.png)

JCore - Документация на фреймворк:

JCore - легковестный фреймворк для создания простых веб-приложений и API-сервисов, построенный на сокетной коммуникации
и состоит из 4х главных компонентов:

1) DI - внедрение зависимостей 
2) взаимодействии с базой данных (под копотом jdbc) - создание обьектов на базе описанных сущностей (src/main/java/vendor/EntityOrm).
3) обработка данных при помощи контроллеров, работа сервера (src/main/java/vendor/ControllerComponent).
4) защита роутов - Security модуль.

Рассмотрим два этих компонента поподробнее:

Глава1: Начиная

#ВНЕДРЕНИЕ ЗАВИСИМОСТЕЙ (DI)
Dependensy Injection (DI) - внедрение компонентов обьектов, считающихся системной частью фреймворка производится по пути:
vendor/DI

Имеются 2 основных компонента:
I) ContainerDI - хранит в себе, непосредственно, сам DI контейнер в формате HashMap<Key, Value>:
	- Где Key - тип класса обьекта, которого нужно достать
	- А Value - сам обьект, который будем внедрять.

	Также имеются 2 метода:
	1) register - для регистрации обьекта как зависимость (по сути, метод-сеттер для задачи значения в контейнер DI)
	2) getBean - для взятия обьекта по типу класса.

	все методы являются статичными, потому как, для управления контейнером зависимостей создавать его обьект не требуется.

II) ConfigDI - отвечает за внедрение в контейнер по умолчанию всех необходимых системных компонентов бинов (обьектов).
	Имеет в себе статический метод setBeans(), который как раз заполняет контейнер 3мя дэфолтными компонентами (обьектами):
	1) обьект Controller - для маршрутизации запросов клиента в контроллеры.
	2) обьект Server([бин компонента Controller для маршрутизации], [порт, на котором будет работать]) - для работы сервера, роутинга по контроллерам и обработки клиентских запросов
	3) обьект Connection - для подключения к бд, является компонентом JDBC. Отвечает за подключение к БД (по данным из конфига для бд - ConfigJDBC)
	4) обьект Statement - выполняет запросы бд на основе обьекта подключения (из пункта 2). Его нужно будет часто передавать в классы-контроллеры и классы-сущности, в качестве параметра конструктора для выполнения запросов под капотом

- этот метод вызывается при старте приложения, в методе main() - самый первый, для инициализации контейнера (установки в него обьектов)

На основе этого вы можете легко внедрять свои модули в контейнер через конфиг, и легко брать из контейнера по типу класса в качестве ключа, вызывая метод getBean класса ContainerDI
Глава2: Взаимодействие с базой данных, работа с сущностями

#КОНФИГУРАЦИЯ
Все основные компоненты фреймворка находятся по пути src/main/java/vendor, и являются самописными на языке java.

Начнем с рассмотрения компонента базы данных (src/main/java/vendor/EntityOrm), за это отвечает главный класс Entity в папке фреймворка
src/main/java/vendor/EntityOrm/Entity.

Но перед тем, как использовать этот класс нужно:
1) в конфигурационном файле управлением JDBC (src/main/java/vendor/EntityOrm/ConfigJDBC)
 - настроить строку подключения к БД на свою (переменная urlConnection)
 - настроить пользователя и пароль к бд на свои (переменные userName и password соответственно)

По умолчанию, в проекте, в файле с зависимостями .pom стоит зависимость от postgreSql (можно заменить на любой другой драйвер реляционной бд)

После конфигурирования базы данных приступим к созданию подключения, в главном запускающем классе (пока что для демонстрации) пропишим необходимые для подключения строки:

```java
public class JCore {

    public static void main(String[] args) throws SQLException, IllegalArgumentException, IllegalAccessException, IOException {
	...
	
        //инициализация бинов в контейнере
        ConfigDI.setBeans(); 
	/*
	 как раз вызов метода инициализации бинов создает обьекты, необходимые для выполнения запросов к бд, и не полько;
	*/ 
	...
```

#СУЩНОСТИ
После настройки базы данных приступим к созданию сущности:

В данном фреймворке сущности строятся полностью на базе аркитектуры любого класса, допустим у нас есть две сущности:
Пользователь (Person) и Автомобиль (Car). Представим, что в нашей системе у каждого Автомобиля автомобиля обязательно будет свой Пользователь
=> связь между сущностями 1:М (Ключ пользователя будет от автомобиля).

Посмотрим на реализацию такой схемы в JCore:

Пользователь:

```java
package com.mycompany.jcore.entities;
import java.sql.Statement;
import vendor.EntityOrm.Entity;

public class Person extends Entity {
    public String name;
    public String surname;

    public Person(Statement statement) {
        super(statement); // передаем обьект для создания запросов родителю
    }    
}
```

- в этом классе мы обозначили, что в нашей сущности Пользователь (а позже и в нашей таблице) будет 2 аттрибута:
Имя и Фамилия - для простого примера нам будет достаточно.
Также данный класс не имеет поля с первичным идентификатором, но главная его особенность в том, что он наследуется од абстрактного класса Entity,
что позваляет классу Person иметь все свойства компонента сущности, такие как:
 - id - первичный ключ
 - refs - ссылки на сушности (внешние ключи в формате ArrayList<RelationField> - об этом позже)
 - statement - стандартный обьект класса jdbc - Statement для выполнения SQL комманд (который как раз и принимает в себя конструктор класса Entity, для реализации в потомке)

а также методы:
 - initializeChild - создание обьекта с метаданными потомка на основании которых будет строиться управление последующими классами.
 - createTable - создание таблиц в БД на базе метаданных сущности
 - insertData - вставка данных в сущность этого типа.

Все эти методы имеют одну очень важную особенность - они необходимы для внутреннего использования
(отвечают за инициализацию метаданных сущности, построение таблиц на основании этих метаданных в базе данных, вставку данных в формате обьекта этой сущности) 
Они используются для построения модели, и ни в коем случае не должны взаимодействовать с данными клиента напрямую, так как доверять введенным данным клиента нельзя,
(например insertData - во избежание SQL-иньекций и тд).

Для работы с выборкой и базой данных на основании данных, предоставляемых клиентом был разработан отдельный безопасный метод:
 - executeSQL - принимает запрос, и отдельно параметры, во избежание SQL-иньекций.

Далее - описание сущности Машины:

```java
package com.mycompany.jcore.entities;
import java.sql.Statement;
import vendor.EntityOrm.Entity;
import vendor.EntityOrm.RelationField;

public class Car extends Entity {
    public String mark;
    public String color;
    public Long personId; //ключи - всегда называем в loverCamelCase, имя связующего класса + постфикс "Id" в конце названия
    
    //связь
    public Car(Statement statement) {
        super(statement); // передаем обьект для создания запросов родителю
        
        refs.add(new RelationField(Person.class, personId)); //связь с персоной машины
    }
}
```

 - здесь уже добавляется поле personId, которое является внешним ключом на сущность Пользователя, тут интересно правило наименования ключа:
[имяКлассаНаКотороеСсылветсяПоле] + Id - в нашем случае имя класса для связки Person, значит по правилу - получаем внешний ключ personId, и тд...

Также, в конструкторе, помимо передачи обьекта для выполнения комманд statement в родительский класс Entity, также в лист со внешними ключами refs создаем новый элемент-ссылку на класс
refs.add(new RelationField(Person.class, personId)); //связь с персоной машины

Поздравляю! теперь мы подготовили нашу структуру данных для ее использования.

#ИСПОЛЬЗОВАНИЕ СУЩНОСТЕЙ

Для работы с сущностями и граммотного построения архитектуры, создадим репозитории к сущностям
- все основное управление над сущностями происходит через репозиторный класс, который должен содержать методы с выборкой данных из сущности для удобного взятия данных.

Создадим такие классы для наших обеих сущностей:

```java
package com.mycompany.jcore.repository;

import com.mycompany.jcore.entities.Car;
import vendor.EntityOrm.Entity;
import vendor.EntityOrm.Repository;

/**
 * Пример репозитория сущности Car.
 * 
 * Репозитории всегда наследуются от Repository<ENTITY, DTO>
 * так как он имеет все необходимые свойства и методы для всех репозиториев
 * - создание таблиц на основании сущности в базе данных
 * - передача обьекта сущности для извлечения из нее данных и вставку в базу данных 
 * @author User
 */
public class CarRepository extends Repository<Car, Car>{
    
    public CarRepository(Car entityClass) {
        super(entityClass);
    }
    
    /**
     * Можете создавать свои методы с выборкой данных из этой сущности
     * (репозиторные функции на взятие данных из базы данных)
     */
}
```

- здесь мы наследуем компонент Repository<>, который имеет обьект сущности для управления над ним, который мы передаем через конструктор, а также основные методы:
 - init - для создания таблицы БД, на основании сущности (только для внутреннего использования т.к. вызывается Entity.createTable и Entity.initializeChild)
 - setData - для установки значения в формате обьекта сущности (только для внутреннего использования т.к. вызывается Entity.initializeChild)

Далее - для создания таблиц в базе данных, на основании созданных сущностей, необходимо в их репозиториях вызвать метод init, что, в свою очередь, создаст все таблицы на основании описанных нами сущностей.

Для этого, необходимо зарегестрировать наши боьекты сущностей в DI-контейнере:
Перейдем в vendor/DI/ConfigDI и пропишим следующее:

```java
/**
 *  Это конфиг для регистрации бинов в проекте для удобного доступа к зависимостям извне
 * @author User
 */
public class ConfigDI {

    /**
     * Конфиг, для создания и выкладки бинов в контейнер
     * 
     * Задаем базовые бины в контейнер (для дальнейшего внедрения).
     * @throws SQLException 
     */
    public static void setBeans() throws SQLException
    {
        ...

        /*
        Ваши бины можете регестрировать здесь (сущности, репозитории и тд)
        (Контроллеры (их обьекты) регестрируются в обьекте бина сервера, в обьекте Controller controllerPull,
        кладутся в List<Object> declaredControllers - это сделанно для роутинга)
        */
        
        //регестрируем наши сущности (наши машину и пользователя, как пример)
        ContainerDI.register(Car.class, new Car(ContainerDI.getBean(Statement.class)));
        ContainerDI.register(Person.class, new Person(ContainerDI.getBean(Statement.class)));
        
        //регестрируем наши репозитории (наши машину и пользователя, как пример)
        ContainerDI.register(CarRepository.class, new CarRepository(ContainerDI.getBean(Car.class)));
        ContainerDI.register(PersonRepository.class, new PersonRepository(ContainerDI.getBean(Person.class)));
    }
}
```

- - здесь, на основе наших сущностей мы создаем обьекты и из нашего DI контейнера передаем каждой сущности обьект Statement в их конструктор, для выполнения запросов в БД под копотом.
Мы регестрируем все наши сущности, потом регестрируем их репозитории, в конструктор которых кладем недавно зарегестрированные их сущности.
Это делаем для того, чтобы при старте программы и инициализации контейнеризатора просто достать из нашего DI контейнера по классу наш обьект репозитория и вызвать у него нужный нам метод init.

Как раз сейчас мы это и сделаем:
В запускающем методе main() нашей программы пропишем следующее:

```java
public class JCore {

    public static void main(String[] args) throws SQLException, IllegalArgumentException, IllegalAccessException, IOException, Exception {
        //инициализация бинов в контейнере
        ConfigDI.setBeans(); //Эта строчка очень важна - без нее контейнеризатор не возьмет наши обьекты, прописанные в конфиге!
        
        /*
        создаем таблицы в правильном порядке на основе сущностей (нужно делать при старе программы)
        (от справочников к связующим таблицам) - ВАЖНО!!!
        путем вызова метода init() в репозиторных бинах наших сущностей.
        */
        ContainerDI.getBean(PersonRepository.class).init();
        ContainerDI.getBean(CarRepository.class).init();
        
        
        /* 
            //пример работы с БД - вставка данных в сущности в формате обьекта с данными.
            //необязательно к реализации - использовать в зависимости от необходимости.
        
            // Создаем сущность c данными
            Person person1 = ContainerDI.getBean(Person.class); //берем сущность Person из контейнера

            //заполняем его данными
            //person1.id = 1; //устанавливать не обязательно - serial счетчик
            person1.name = "Иван";
            person1.surname = "Иванов";

            //вызываем метод setData() и передаем данные в виде обьекта для создания записи в базе данных.
            ContainerDI.getBean(PersonRepository.class).setData(person1);

            // тоже самое с машиной
            Car car1 = ContainerDI.getBean(Car.class); //берем сущность Car из контейнера

            //заполняем ее данными
            //car1.id = 1; //устанавливать не обязательно - serial счетчик
            car1.mark = "Таета";
            car1.color = "черный";
            car1.personId = Long.valueOf("1");

            //вызываем метод setData() и передаем данные в виде обьекта для создания записи в базе данных.
            ContainerDI.getBean(CarRepository.class).setData(car1);
        */
        
        
        //запуск сервера
        Server server = ContainerDI.getBean(Server.class); //берем бин сервера из DI-контейнера
        
        // регестрируем все наши контроллеры на сервере (для роутинга)
        server.controllerPull.declaredControllers.add(new PersonController(ContainerDI.getBean(Statement.class)));
        
        server.startServer(); //запускаем сервер
    }
```

- здесь очень важная деталь - создаем таблицы в правильном порядке на основе сущностей (нужно делать при старе программы)
        (от справочников к связующим таблицам) - ВАЖНО!!! То есть сначала таблицы без связей, потом связующие этих таблиц (от справочников к связующим).

При старте программы, после того как в main() отработают следующие важные для нас в этом разделе строчки:
 ConfigDI.setBeans(); - создание бинов в контейнере из конфигурации
        
 ContainerDI.getBean(PersonRepository.class).init(); - инициализация (создание таблицы на основании сущности) репозиторным классом сущности Person (таблица без ключей)
 ContainerDI.getBean(CarRepository.class).init(); - инициализация (создание таблицы на основании сущности) репозиторным классом сущности Car (таблица с ключом на Person)

- можно будет официально заявить о создании описанных сущностей в базе данных в виде таблиц.

для заполнения таблиц данными, можно выполнить следующий код, после инициализации сущностей:

```java
/* 
            //пример работы с БД - вставка данных в сущности в формате обьекта с данными.
            //необязательно к реализации - использовать в зависимости от необходимости.
        
            // Создаем сущность c данными
            Person person1 = ContainerDI.getBean(Person.class); //берем сущность Person из контейнера

            //заполняем его данными
            //person1.id = 1; //устанавливать не обязательно - serial счетчик
            person1.name = "Иван";
            person1.surname = "Иванов";
            person1.login = "ivanov";
            person1.password = "pass";
            person1.role = "USER";

            //вызываем метод setData() и передаем данные в виде обьекта для создания записи в базе данных.
            ContainerDI.getBean(PersonRepository.class).setData(person1);

            // тоже самое с машиной
            Car car1 = ContainerDI.getBean(Car.class); //берем сущность Car из контейнера

            //заполняем ее данными
            //car1.id = 1; //устанавливать не обязательно - serial счетчик
            car1.mark = "Таета";
            car1.color = "черный";
            car1.personId = Long.valueOf("1");

            //вызываем метод setData() и передаем данные в виде обьекта для создания записи в базе данных.
            ContainerDI.getBean(CarRepository.class).setData(car1);
*/
```

ПОЗДРАВЛЯЮ!!! вы создали схему таблиц и заполнили ее данными из обьектов.


Глава3: Обработка данных при помощи контроллеров, работа сервера.

#КОНТРОЛЛЕРЫ, МАРШРУТИЗАЦИЯ И РОУТИНГ

Для примера, создадим класс-контроллер, который будет запускаться каждый раз, при обращении к нему запроса от клиента:

```java
package com.mycompany.jcore.controller;

import java.sql.Statement;
import vendor.Security.Security;

/**
 * Пример контроллера с выводом переданных параметров клиенту.
 * @author User
 */
public class PersonController {
    
    /* telnet 127.0.0.1 8082
    запрос (через коммандную строку): PersonController/createPersonAction<endl>helloWorld!<endl>JCore!<endl>
    */
    public String createPersonAction(String[] params)
    {
        String result = "";
        
        for(String param : params)
        {
            result += "param is -> " + param + "\r\n";
            System.out.println("param is -> " + param);
        }
            
        return result;
    }
}
```

- Здесь очень важно правильно назвать класс-контроллер и его методы (экшены), ведь из них складывается строка к доступу (роуту) для выполнения метода.
String[] params - переданные параметры от клиента в строке запроса от него (request).

Отлично, мы написали класс-контроллер с примером вывода в консоль всех переданных параметров клиента и возвращением параметров клиента с сервера обратно клиенту как ответ сервера (response).

Далее механизм роутинга мы осветим чуть подробнее:


#СЕРВЕР

Сервер представляет из себя класс Server, который отвечает за связку клиента с программой путем соединения через ServerSocket.
Клиент подключается к серверу, отдает запрос -> сервер обрабатывает запрос, формирует ответ -> возвращает ответ клиенту и закрывает соединение.
И так обрабатывается каждый запрос.

Запрос клиента состоит из роута, в формате "классКонтроллера/методДляВыполнения<endl>данные параметра 1<endl>данные параметра 2<endl>..."
- данные параметров в запросе клиента может быть сколько угодно.

Ответ от сервера принимается в формате строки.

(Все современные браузеры получают данные в формате строки, которая в свою очередь парсится и преобразоввывается сериализатором обратно в обьект,
а ответ - обработанные данные, которые в свою очередь также представляются в виде строки, которую должна быт распаршена на клиентской части для извлечения и отрисовки данных,
поэтому был выбран такой архитектурный прием в виде строки-запроса, данные которой парсятся в массив параметров в данном фреймворке и строки-ответа,
которая, в свою очередь, должна быть распаршена на стороне клиента).

Очень важный момент - сервер имеет в себе обьект Controller, который хранит в себе все роуты для отправки в них запросов на клиенте (об этом подробнее чуть позже).

Для запуска и корректной работы сервера для работоспособности нашего написанного выше контроллера, в main запускающем методе требуется прописать следующее:

```java
public static void main(String[] args) {
	//инициализация бинов в контейнере
        ConfigDI.setBeans(); //(1)
        
        //запуск сервера
        Server server = ContainerDI.getBean(Server.class); //берем бин сервера из DI-контейнера (2)
        
        // регестрируем все наши контроллеры на сервере (для роутинга) (3)
        server.controllerPull.declaredControllers.add(new PersonController());
        
        server.startServer(); //запускаем сервер (4)
}
```

- здесь мы инициализируем DI-контейнер т.к. наш обьект сервера находится в нем (1),
на второй строке - берем обьект сервера из контейнера для дальнейшего взаимодействия с ним (2),
у обьекта сервера есть поле controllerPull типа класса Controller, в реализации которого есть коллекция declaredControllers<>,
которая хранит в себе все обьекты контроллеров, которые будут работать на сервере. В нашем случае, в коллекцию контроллеров для сервера мы положим обьект контроллера нашего новосозданного класса PersonController - таким же образом, в коллекцию передаем все наши контроллеры (3).
Далее даем команду серверу на запуск, вызвав у него на обьекте метод startServer (4).

Готово, можно запускать!

Как работает роутинг?

При подключении по Сокетному соединению клиента (telnet [IP-адресс (локально - 127.0.0.1)] [порт (по умолчанию - 8082)])
можно будет отправить запрос в следующем формате:

```text
"PersonController/createPersonAction<endl>helloWorld!<endl>JCore!<endl>"
```

Где PersonController/createPersonAction - имя роута, которое парсится по символу "/", извлекается имя класса и ищется в коллекции declaredControllers<>.
Если обьект класса присутствует в коллекции, у него вызывается метод в роуте, идущий после символа "/".

после определения роута, строка запроса парсится по делиметру строки "&lt;endl&gt;", и все параметры, идущие после роута, передаются в сигнатуру запускающего метода, в параметр String[] params - в нашем случае: createPersonAction(String[] params)


Глава4: Защита роутов, Security модуль.

Защита роута осуществляется путем проверки логина и пароля пользователя (аутентификации пользователя в системе).
Если введенный логин пользователем существует и совпадает вместе с введенным паролем в базе данных, то у пользователя обязательно берется роль из базы данных и сверяется с ролью для доступа к ресурсу (роуту).
Если роли совпадают - пользователь может спокойно осуществить свой запрос по роуту и получить обработанный ответ от сервера.

Посмотрим, как это можно использовать на практике - для начала в сущности пользователя создадим необходимые поля для защиты роута:

```java
package com.mycompany.jcore.entities;
import java.sql.Statement;
import vendor.EntityOrm.Entity;

/**
 * 
 * @author maxim
 */
public class Person extends Entity {
    public String name;
    public String surname;
    
    public String login; //добавляем поле с логином для входа пользователя
    public String password; //добавляем поле с паролем для входа пользователя
    public String role; //добавляем поле с ролью пользователя

    public Person(Statement statement) {
        super(statement); // передаем обьект для создания запросов родителю
    }    
}
```

- в этом примере мы добавляем необходимые поля для дальнейшей работой над защитой нашего роута.

Далее - перейдем в класс-контроллер для защиты нашего роута:

```java
package com.mycompany.jcore.controller;

import java.sql.Statement;
import vendor.Security.Security;

/**
 * Пример контроллера с выводом переданных параметров клиенту.
 * @author User
 */
public class PersonController extends Security { //наследуемся от компонента Security для защиты роута.
    
    public PersonController(Statement statement) { //в конструкторе передаем обьект JDBC для выполнения запросов (передается в родительский класс Security)
        super(statement);
    }
    
    /* telnet 127.0.0.1 8082
    запрос (через коммандную строку): PersonController/createPersonAction<endl>helloWorld!<endl>JCore!<endl>ivanov<security>;pass<endl>
    */
    public String createPersonAction(String[] params)
    {
        String result = ""; //строка с ответом от сервера, которую будем возвращать клиенту.
        
	//([из какой таблицы], [имя поля логина в таблице], [имя поля пароля в таблице], [имя поля роли в таблице], [Имя роли, которой можно выполнять запрос], [параметры запроса])
        if(super.checkRole("Person", "login", "password", "role", "USER", params)) { //проверка пользователя (Security-модуль)   
            for(String param : params)
            {
		// если логин и пароль из запроса совпадут со значениями из БД, и роль найденого пользователя будет равна (в нашем случае "USER")
		//то запрос выполнится
                result += "param is -> " + param + "\r\n";
                System.out.println("param is -> " + param);
            }
            
            return result;
        } else {
	    //иначе выведит ошибку доступа.
            return super.returnException();
        }
    }
}
```

- далее - очень важный момент:

1) для Security нужен обьект Statement, поэтому, для его передачи - создаем конструктор.
2) основное условие для доступа по роуту находится в контроллере, и в теле этого условия (в идеале), должен вызываться метод из сервиса, который отвечает за обработку данных и возвращение результата в формате ответа.
3) сигнатура метода checkRole родительского класса состоит из:
([из какой таблицы сравниваем и берем данные для проверки аутентификации], [имя поля логина в таблице], [имя поля пароля в таблице], [имя поля роли в таблице], [Имя роли, которой можно выполнять запрос], [параметры запроса - массив параметров контроллера])
- возвращает Булевое значение и отвечает за то, прошел ли пользователь аутентификацию, либо же нет.
4) Запрос клиента с запросом после подключения модуля Security ОБЯЗАТЕЛЬНО ДОЛЖЕН ИМЕТЬ БЛОК <endl>[логин пользователя для сверки с БД]<security>[пароль пользователя для сверки с БД]<endl>

Например, если у пользователя в БД будет логин - ivanov, а пароль - pass, то целевой запрос к нашему роуту будет выглядеть следующим образом:

```text
PersonController/createPersonAction<endl>helloWorld!<endl>JCore!<endl>ivanov<security>pass<endl>
```

Далее - в запускаемом методе, для примера - вручную создадим сущности и заполним их данными
(Если не в курсе как это делать - смотри 
Главу1: DI - внедрение зависимостей
и Главу2: Взаимодействие с базой данных, работа с сущностями - там это подробно описано):

```java
package com.mycompany.jcore;

import com.mycompany.jcore.controller.PersonController;
import com.mycompany.jcore.entities.Car;
import com.mycompany.jcore.entities.Person;
import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import vendor.ControllerComponent.Connection.Server;
import vendor.ControllerComponent.Controller;
import vendor.DI.ConfigDI;
import vendor.DI.ContainerDI;
import vendor.EntityOrm.ConfigJDBC;
import vendor.JCoreMeta;

/**
 *
 * @author maxim
 */
public class JCore {

    public static void main(String[] args) throws SQLException, IllegalArgumentException, IllegalAccessException, IOException {
        //инициализация бинов в контейнере
        ConfigDI.setBeans(); //Эта строчка очень важна - без нее контейнеризатор не возьмет наши обьекты, прописанные в конфиге!
        
        /*
        создаем таблицы в правильном порядке на основе сущностей (нужно делать при старе программы)
        (от справочников к связующим таблицам) - ВАЖНО!!!
        путем вызова метода init() в репозиторных бинах наших сущностей.
        */
        ContainerDI.getBean(PersonRepository.class).init();
        ContainerDI.getBean(CarRepository.class).init();
        
        
        //пример работы с БД - вставка данных в сущности в формате обьекта с данными.
        
        // Создаем сущность c данными
        Person person1 = ContainerDI.getBean(Person.class); //берем сущность Person из контейнера

        //заполняем его данными
        //person1.id = 1; //устанавливать не обязательно - serial счетчик
        person1.name = "Иван";
        person1.surname = "Иванов";
	person1.password = "pass";
        person1.role = "USER";

        //вызываем метод setData() и передаем данные в виде обьекта для создания записи в базе данных.
        ContainerDI.getBean(PersonRepository.class).setData(person1);

        // тоже самое с машиной
        Car car1 = ContainerDI.getBean(Car.class); //берем сущность Car из контейнера

        //заполняем ее данными
        //car1.id = 1; //устанавливать не обязательно - serial счетчик
        car1.mark = "Таета";
        car1.color = "черный";
        car1.personId = Long.valueOf("1");

        //вызываем метод setData() и передаем данные в виде обьекта для создания записи в базе данных.
        ContainerDI.getBean(CarRepository.class).setData(car1);
        
        
        //запуск сервера
        Server server = ContainerDI.getBean(Server.class); //берем бин сервера из DI-контейнера
        
        // регестрируем все наши контроллеры на сервере (для роутинга)
        server.controllerPull.declaredControllers.add(new PersonController(ContainerDI.getBean(Statement.class)));
        
        server.startServer(); //запускаем сервер
    }
}
```

- запустим программу и совершим запрос - PersonController/createPersonAction<endl>helloWorld!<endl>JCore!<endl>ivanov<security>pass<endl>

Готово! вы увидите, что запрос успешно отработает. Чтобы посмотреть, как он отреагирует на неправильный логин и пароль, можете изменить запрос в блоке

```text
<endl>ivanov<security>pass<endl>
```

- подставив некорректный логин и пароль, например

```text
<endl>ivanov123<security>pass123<endl>
```

- Все основные примеры разобраны, в заключении хочется немного добавить и закрепить очень важные архитектурные нюансы:
Основная логика и обработка данных пишется в сервисах, которые имеют обьекты репозиториев, которые, в свою очередь, должны быть внедрены в класс сервиса через конструктор, путем создания обьекта сервиса в контейнере DI с внедрением в него обьекта репозитория также через контейнер DI.

Контроллер, в свою очередь - получает и обрабатывает данные через соответствующий его сервис, который возвращает результат обратно контроллеру, который также обязуется возвратить контроллер.
Контроллеры, в свою очередь, не регестрируются в DI контейнере, а регестрируются на сервере напрямую, с передачей необходимых параметров из DI-контейнера, которые заранее были прописанны в DI конфигурации.